import { DOC_STORE } from "pouchdb-adapter-indexeddb/src/util";
import { removeLeafFromTree, winningRev } from "pouchdb-merge";

function purgeAttachments(doc, revs) {
  if (!doc.attachments) {
    return {};
  }

  for (let k in doc.attachments) {
    const attachment = doc.attachments[k];

    for (let rev of revs) {
      if (attachment.revs[rev]) {
        delete attachment.revs[rev];
      }
    }

    if (Object.keys(attachment.revs).length === 0) {
      delete doc.attachments[k];
    }
  }

  return doc.attachments;
}

// do we want to make this function remove just one rev for each call, or rather
// operate on an entire path of revs? it could be way cheaper to operate on the
// doc just once, given that the rev path is correct. but we could verify that
// during the transaction.
function purge(txn, docId, revs, callback) {
  if (txn.error) {
    return callback(txn.error);
  }

  const docStore = txn.txn.objectStore(DOC_STORE);
  const deletedRevs = []
  let documentWasRemovedCompletely = false
  docStore.get(docId).onsuccess = (e) => {
    const doc = e.target.result;

    // we could do a dry run here to check if revs is a proper path towards a leaf in the rev tree

    for (const rev of revs) {
      // purge rev from tree
      doc.rev_tree = removeLeafFromTree(doc.rev_tree, rev);

      // assign new revs
      delete doc.revs[rev];
      deletedRevs.push(rev)
    }

    if (doc.rev_tree.length === 0) {
      // if the rev tree is empty, we can delete the entire document
      docStore.delete(doc.id);
      documentWasRemovedCompletely = true;
      return;
    }

    // find new winning rev
    doc.rev = winningRev(doc);
    doc.data = doc.revs[doc.rev].data;
    doc.attachments = purgeAttachments(doc, revs);

    // finally, write the purged doc
    docStore.put(doc);
  };

  txn.txn.oncomplete = function () {
    callback(null, {
      ok: true,
      deletedRevs,
      documentWasRemovedCompletely
    });
  };
}

export default purge;
