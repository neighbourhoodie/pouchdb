import { DOC_STORE } from "pouchdb-adapter-indexeddb/src/util";
import { removeLeafFromTree, winningRev } from "pouchdb-merge";

// do we want to make this function remove just one rev for each call, or rather
// operate on an entire path of revs? it could be way cheaper to operate on the
// doc just once, given that the rev path is correct. but we could verify that
// during the transaction.
function purge(txn, docId, rev, callback) {
  if (txn.error) {
    return callback(txn.error);
  }

  const docStore = txn.txn.objectStore(DOC_STORE);
  docStore.get(docId).onsuccess = (e) => {
    const doc = e.target.result;

    // look into how docs are updated (and hence, how rev trees are updated)
    // that stuff lives in `bulkDocs`
    doc.rev_tree = removeLeafFromTree(doc.rev_tree, rev);

    // assign new revs
    delete doc.revs[rev];

    // find new winning rev
    // do we want to calculate the winning rev for each purged rev? when purging a branch like a-b-c
    // (c is leaf and previous winning rev), this could mean that during the first rev purge (c) a
    // winning rev of another branch is calculated. hence, b and c will choose the same winning rev.
    // considering this, purging an entire with in a single transaction/operation would make even
    // more sense.
    doc.rev = winningRev(doc);
    doc.data = doc.revs[doc.rev].data;

    // finally, write the purged doc
    docStore.put(doc);
  };

  txn.txn.oncomplete = function () {
    callback();
  };
}

export default purge;
