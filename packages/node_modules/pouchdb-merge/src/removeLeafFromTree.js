import { clone } from 'pouchdb-utils';

// this method removes a leaf from a rev tree, independent of its status.
// e.g., by removing an available leaf, it could leave its predecessor as
// a missing leaf and corrupting the tree.
function removeLeafFromRevTree(tree, leafRev) {
  return tree.flatMap((path) => {
    path = removeLeafFromPath(path, leafRev);
    return path ? [path] : [];
  });
}

function removeLeafFromPath(path, leafRev) {
  const _tree = clone(path);
  const toVisit = [_tree];

  // we will store branchings (node.branches > 1) as a LIFO stack
  const branchings = [];

  let previousNode;
  let node;
  while ((node = toVisit.pop())) {
    const pos = node.pos;
    const [id, , branches] = node.ids;
    const isLeaf = branches.length === 0;
    const hash = `${pos}-${id}`;

    if (isLeaf && hash === leafRev) {
      if (!previousNode) {
        // FIXME: we're facing the root, and probably shouldn't just return an empty array (object? null?).
        return null;
      }

      previousNode.ids[2] = previousNode.ids[2].filter(function (branchNode) {
        return branchNode[0] !== id;
      });
      return _tree;
    }

    if (branches.length) {
      if (branches.length > 1) {
        branchings.push(node);
      }

      for (let i = 0, len = branches.length; i < len; i++) {
        toVisit.push({pos: pos + 1, ids: branches[i]});
      }
    }

    if (branches.length === 0 && branchings.length > 0) {
      previousNode = branchings.pop();
    }  else {
      previousNode = node;
    }
  }
  return _tree;
}

export default removeLeafFromRevTree;
