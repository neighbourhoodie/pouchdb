import Adapter from './adapter';
import TaskQueue from './taskqueue';
import { clone } from 'pouchdb-utils';
import parseAdapter from './parseAdapter';
import { createClass } from './utils';

// OK, so here's the deal. Consider this code:
//     var db1 = new PouchDB('foo');
//     var db2 = new PouchDB('foo');
//     db1.destroy();
// ^ these two both need to emit 'destroyed' events,
// as well as the PouchDB constructor itself.
// So we have one db object (whichever one got destroy() called on it)
// responsible for emitting the initial event, which then gets emitted
// by the constructor, which then broadcasts it to any other dbs
// that may have been created with the same name.
function prepareForDestruction(self) {

  function onDestroyed(from_constructor) {
    self.removeListener('closed', onClosed);
    if (!from_constructor) {
      self.constructor.emit('destroyed', self.name);
    }
  }

  function onClosed() {
    self.removeListener('destroyed', onDestroyed);
    self.constructor.emit('unref', self);
  }

  self.once('destroyed', onDestroyed);
  self.once('closed', onClosed);
  self.constructor.emit('ref', self);
}

class PouchInternal extends Adapter {
  constructor(name, opts) {
    super();
    this._setup(name, opts);
  }

  _setup(name, opts) {
    super.constructor();
    var self = this;
    opts = opts || {};

    if (name && typeof name === 'object') {
      opts = name;
      name = opts.name;
      delete opts.name;
    }

    if (opts.deterministic_revs === undefined) {
      opts.deterministic_revs = true;
    }

    this.__opts = opts = clone(opts);

    self.auto_compaction = opts.auto_compaction;
    self.prefix = PouchInternal.prefix;

    if (typeof name !== 'string') {
      throw new Error('Missing/invalid DB name');
    }

    var prefixedName = (opts.prefix || '') + name;
    var backend = parseAdapter(prefixedName, opts);

    opts.name = backend.name;
    opts.adapter = opts.adapter || backend.adapter;

    self.name = name;
    self._adapter = opts.adapter;
    PouchInternal.emit('debug', ['adapter', 'Picked adapter: ', opts.adapter]);
    this.emit('debug', ['adapter', 'Picked adapter: ', opts.adapter]);

    if (!PouchInternal.adapters[opts.adapter] ||
        !PouchInternal.adapters[opts.adapter].valid()) {
      throw new Error('Invalid Adapter: ' + opts.adapter);
    }

    self.taskqueue = new TaskQueue();

    self.adapter = opts.adapter;

    PouchInternal.adapters[opts.adapter].call(self, opts, function (err) {
      if (err) {
        return self.taskqueue.fail(err);
      }
      prepareForDestruction(self);

      self.emit('created', self);
      PouchInternal.emit('created', self.name);
      self.taskqueue.ready(self);
    });
  }
}

const PouchDB = createClass(PouchInternal, function (name, opts) {
  PouchInternal.prototype._setup.call(this, name, opts);
});

export default PouchDB;
